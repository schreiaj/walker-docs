<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="color-scheme" content="light dark">
    <title>How does a walking robot walk?</title>
    <meta name="description" content="Explorable explainer of how to sequence legs for walking robots.">

    <!-- Pico.css -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2.1.1/css/pico.min.css">
</head>

<body>
    <!-- Header -->
    <header class="container">
        <hgroup>
            <h1>Walker Leg Sequencing Example</h1>
            <p>Let's explore a naive method of sequencing legs for walking robots.</p>
        </hgroup>
    </header>
    <!-- ./ Header -->


    <script>

        const singleLegData = [
            { xOffset: 4, yOffset: 0, tOffset: 0, color: "red" },
        ]

        const singleLegSequence = [
            [0, 0, 0],
            [0, 0, .25],
            [2, 0, .25],
            [2, 0, 0],
            [1, 0, 0],
        ]

        const fourLegNoOffsetData = [
            { xOffset: 3, yOffset: 3, tOffset: 0, color: "red" },
            { xOffset: 3, yOffset: -3, tOffset: 0, color: "green" },
            { xOffset: -3, yOffset: 3, tOffset: 0, color: "blue" },
            { xOffset: -3, yOffset: -3, tOffset: 0, color: "yellow" },
        ]

        const fourLegOffsetData = [
            { xOffset: 3, yOffset: 3, tOffset: 0, color: "red" },
            { xOffset: 3, yOffset: -3, tOffset: 2, color: "green" },
            { xOffset: -3, yOffset: 3, tOffset: 4, color: "blue" },
            { xOffset: -3, yOffset: -3, tOffset: 6, color: "yellow" },
        ]

        const fourLegOffsetSequence = [
            [0, 0, 0],
            [0, 0, .25],
            [2, 0, .25],
            [2, 0, 0],
            [1.5, 0, 0],
            [1, 0, 0],
            [0.5, 0, 0],
            [0, 0, 0],
        ]

        const computeLegTarget = (leg, t, speed, heading, angularRate, gaitSequence) => {
            const { xOffset, yOffset, tOffset } = leg;
            const gaitIndex = gaitSequence[(t + tOffset) % gaitSequence.length];

            // Determine if the leg is on the right or left side relative to the heading direction
            // Project the leg position onto the perpendicular to the heading direction
            const perpX = -Math.sin(heading);
            const perpY = Math.cos(heading);
            const dotProduct = xOffset * perpX + yOffset * perpY;
            const isRight = dotProduct > 0;

            // Apply differential steering by scaling the speed based on leg position
            // The angular rate creates a turning radius - inside legs move slower, outside legs move faster
            // When speed=0 and angularRate>0, inside legs move backward (turning in place)
            // When speed>0 and angularRate>0, inside legs move slower but still forward (turning while moving)
            const effectiveSpeed = speed + (isRight ? -angularRate : +angularRate);

            // Apply the heading rotation to the gait sequence
            const xGait = Math.cos(heading) * gaitIndex[0] - Math.sin(heading) * gaitIndex[1];
            const yGait = Math.sin(heading) * gaitIndex[0] + Math.cos(heading) * gaitIndex[1];

            // Apply the effective speed to the gait sequence
            const x = xOffset + effectiveSpeed * xGait;
            const y = yOffset + effectiveSpeed * yGait;
            const z = gaitIndex[2];

            return { x, y, z, isRight }
        }


    </script>
    <!-- Main -->
    <main class="container">
        <section id="intro">
            <p>
                There are many different ways to control legs for a walking robot. The simplest approach is to have each leg follow a repeating pattern called a gait sequence. The main downside is that the robot doesn't know what surface it's walking on, so it will struggle over uneven terrain. But for getting a robot moving and for simple remote-controlled robots, this approach works well to start with.
            </p>
        </section>
        <!-- Preview -->
        <section id="single-leg">
            <h2>Let's start with a single leg</h2>
            <p>
                We're going to look at where the leg should move to. Getting the leg to actually move to that target is called inverse kinematics, which is a different topic.
            </p>
            <p>
                Below you'll see a red circle representing where the leg should move and a black circle representing the robot's body.
            </p>
            <div data-signals="{singleT: 0, singleLegEnabled: false}"
                data-on-interval__duration.200ms="$singleLegEnabled && $singleT++">

                <div style="display: flex; flex-direction: column; align-items: center; gap: 10px; padding: 10px;">
                    <svg viewBox="-10 -10 20 20" width="200" height="200">
                        <circle r="1" cx="0" cy="0" stroke="light-dark(black, white)" fill="none" stroke-width="0.25">
                        </circle>
                        <circle
                            data-attr-cx="singleLegData[0].xOffset+singleLegSequence[($singleT + singleLegData[0].tOffset)%singleLegSequence.length][0]"
                            data-attr-cy="singleLegData[0].yOffset+singleLegSequence[($singleT + singleLegData[0].tOffset)%singleLegSequence.length][1]"
                            data-attr-r="0.5+singleLegSequence[($singleT + singleLegData[0].tOffset)%singleLegSequence.length][2]"
                            data-attr-fill="singleLegSequence[($singleT + singleLegData[0].tOffset)%singleLegSequence.length][2] > 0 ? 'none' : singleLegData[0].color"
                            data-attr-stroke="singleLegData[0].color" stroke-width="0.25"></circle>

                    </svg>
                    <button data-on-click="$singleLegEnabled = !$singleLegEnabled"><span
                            data-text="$singleLegEnabled ? 'Stop' : 'Start'"></span> Animation</button>
                </div>
                There are 4 distinct phases to the leg's movement:
                <ol>
                    <li><strong>Lift</strong> - the leg lifts from the ground</li>
                    <li><strong>Swing</strong> - the leg swings forward in the direction of travel</li>
                    <li><strong>Land</strong> - the leg lands on the ground</li>
                    <li><strong>Retract</strong> - the leg pulls back toward the body</li>
                </ol>
                <p>You'll notice the circle representing the leg gets bigger when it's in the air. This is just a visual effect since we're working in 2D.</p>
            </div>

        </section>

        <section id="single-leg">
            <h2>And some more legs...</h2>
            <p>
                We're going to start with 4 legs because it's easier to see what's happening with fewer legs.
            </p>
            <p>
                Now we've added 3 more legs and are running the same movement pattern on each leg.
            </p>
            <div
                data-signals="{fourLegNoOffsetT: 0, fourLegNoOffsetEnabled: false, fourLegOffsetT: 0, fourLegOffsetEnabled: false}">

                <div style="display: flex; flex-direction: column; align-items: center; gap: 10px; padding: 10px;"
                    data-on-interval__duration.200ms="$fourLegNoOffsetEnabled && $fourLegNoOffsetT++"">
                    <svg viewBox=" -10 -10 20 20" width="200" height="200">
                    <circle r="1" cx="0" cy="0" stroke="light-dark(black, white)" fill="none" stroke-width="0.25">
                    </circle>
                    <circle
                        data-attr-cx="fourLegNoOffsetData[0].xOffset+singleLegSequence[($fourLegNoOffsetT + fourLegNoOffsetData[0].tOffset)%singleLegSequence.length][0]"
                        data-attr-cy="fourLegNoOffsetData[0].yOffset+singleLegSequence[($fourLegNoOffsetT + fourLegNoOffsetData[0].tOffset)%singleLegSequence.length][1]"
                        data-attr-r="0.5+singleLegSequence[($fourLegNoOffsetT + fourLegNoOffsetData[0].tOffset)%singleLegSequence.length][2]"
                        data-attr-fill="singleLegSequence[($fourLegNoOffsetT + fourLegNoOffsetData[0].tOffset)%singleLegSequence.length][2] > 0 ? 'none' : fourLegNoOffsetData[0].color"
                        data-attr-stroke="fourLegNoOffsetData[0].color" stroke-width="0.25"></circle>
                    <circle
                        data-attr-cx="fourLegNoOffsetData[1].xOffset+singleLegSequence[($fourLegNoOffsetT + fourLegNoOffsetData[1].tOffset)%singleLegSequence.length][0]"
                        data-attr-cy="fourLegNoOffsetData[1].yOffset+singleLegSequence[($fourLegNoOffsetT + fourLegNoOffsetData[1].tOffset)%singleLegSequence.length][1]"
                        data-attr-r="0.5+singleLegSequence[($fourLegNoOffsetT + fourLegNoOffsetData[1].tOffset)%singleLegSequence.length][2]"
                        data-attr-fill="singleLegSequence[($fourLegNoOffsetT + fourLegNoOffsetData[1].tOffset)%singleLegSequence.length][2] > 0 ? 'none' : fourLegNoOffsetData[1].color"
                        data-attr-stroke="fourLegNoOffsetData[1].color" stroke-width="0.25"></circle>
                    <circle
                        data-attr-cx="fourLegNoOffsetData[2].xOffset+singleLegSequence[($fourLegNoOffsetT + fourLegNoOffsetData[2].tOffset)%singleLegSequence.length][0]"
                        data-attr-cy="fourLegNoOffsetData[2].yOffset+singleLegSequence[($fourLegNoOffsetT + fourLegNoOffsetData[2].tOffset)%singleLegSequence.length][1]"
                        data-attr-r="0.5+singleLegSequence[($fourLegNoOffsetT + fourLegNoOffsetData[2].tOffset)%singleLegSequence.length][2]"
                        data-attr-fill="singleLegSequence[($fourLegNoOffsetT + fourLegNoOffsetData[2].tOffset)%singleLegSequence.length][2] > 0 ? 'none' : fourLegNoOffsetData[2].color"
                        data-attr-stroke="fourLegNoOffsetData[2].color" stroke-width="0.25"></circle>
                    <circle
                        data-attr-cx="fourLegNoOffsetData[3].xOffset+singleLegSequence[($fourLegNoOffsetT + fourLegNoOffsetData[3].tOffset)%singleLegSequence.length][0]"
                        data-attr-cy="fourLegNoOffsetData[3].yOffset+singleLegSequence[($fourLegNoOffsetT + fourLegNoOffsetData[3].tOffset)%singleLegSequence.length][1]"
                        data-attr-r="0.5+singleLegSequence[($fourLegNoOffsetT + fourLegNoOffsetData[3].tOffset)%singleLegSequence.length][2]"
                        data-attr-fill="singleLegSequence[($fourLegNoOffsetT + fourLegNoOffsetData[3].tOffset)%singleLegSequence.length][2] > 0 ? 'none' : fourLegNoOffsetData[3].color"
                        data-attr-stroke="fourLegNoOffsetData[3].color" stroke-width="0.25"></circle>
                    </svg>
                    <button data-on-click="$fourLegNoOffsetEnabled = !$fourLegNoOffsetEnabled"><span
                            data-text="$fourLegNoOffsetEnabled ? 'Stop' : 'Start'"></span> Animation</button>
                </div>
                <p>You might have noticed that the robot would just be moving in a circle without actually going anywhere. We can fix this by adding time offsets to each leg's movement pattern. This makes the legs move in sequence instead of all at once.</p>

                <p>However, this adds a new requirement to our movement pattern. The retract phase needs to be longer than the other phases.</p>
                
                <p>How much longer depends on what type of walking pattern you're using. For the simplest "lift one leg at a time" pattern, you need to make sure that when any one leg is in the air, the remaining legs are on the ground.</p>
                
                <p>We've made it clear when the legs are in the air by making the circles unfilled. Now let's see if we can adjust the movement pattern and add the right time offsets.</p>


                <div style="display: flex; flex-direction: column; align-items: center; gap: 10px; padding: 10px;"
                    data-on-interval__duration.200ms="$fourLegOffsetEnabled && $fourLegOffsetT++">
                    <svg viewBox="-10 -10 20 20" width="200" height="200">
                        <circle r="1" cx="0" cy="0" stroke="light-dark(black, white)" fill="none" stroke-width="0.25">
                        </circle>
                        <circle
                            data-attr-cx="computeLegTarget(fourLegOffsetData[0], $fourLegOffsetT, 1, 0, 0, fourLegOffsetSequence).x"
                            data-attr-cy="computeLegTarget(fourLegOffsetData[0], $fourLegOffsetT, 1, 0, 0, fourLegOffsetSequence).y"
                            data-attr-r="0.5+computeLegTarget(fourLegOffsetData[0], $fourLegOffsetT, 1, 0, 0, fourLegOffsetSequence).z"
                            data-attr-fill="computeLegTarget(fourLegOffsetData[0], $fourLegOffsetT, 1, 0, 0, fourLegOffsetSequence).z > 0 ? 'none' : fourLegOffsetData[0].color"
                            data-attr-stroke="fourLegOffsetData[0].color" stroke-width="0.25"></circle>
                        <circle
                            data-attr-cx="computeLegTarget(fourLegOffsetData[1], $fourLegOffsetT, 1, 0, 0, fourLegOffsetSequence).x"
                            data-attr-cy="computeLegTarget(fourLegOffsetData[1], $fourLegOffsetT, 1, 0, 0, fourLegOffsetSequence).y"
                            data-attr-r="0.5+computeLegTarget(fourLegOffsetData[1], $fourLegOffsetT, 1, 0, 0, fourLegOffsetSequence).z"
                            data-attr-fill="computeLegTarget(fourLegOffsetData[1], $fourLegOffsetT, 1, 0, 0, fourLegOffsetSequence).z > 0 ? 'none' : fourLegOffsetData[1].color"
                            data-attr-stroke="fourLegOffsetData[1].color" stroke-width="0.25"></circle>
                        <circle
                            data-attr-cx="computeLegTarget(fourLegOffsetData[2], $fourLegOffsetT, 1, 0, 0, fourLegOffsetSequence).x"
                            data-attr-cy="computeLegTarget(fourLegOffsetData[2], $fourLegOffsetT, 1, 0, 0, fourLegOffsetSequence).y"
                            data-attr-r="0.5+computeLegTarget(fourLegOffsetData[2], $fourLegOffsetT, 1, 0, 0, fourLegOffsetSequence).z"
                            data-attr-fill="computeLegTarget(fourLegOffsetData[2], $fourLegOffsetT, 1, 0, 0, fourLegOffsetSequence).z > 0 ? 'none' : fourLegOffsetData[2].color"
                            data-attr-stroke="fourLegOffsetData[2].color" stroke-width="0.25"></circle>
                        <circle
                            data-attr-cx="computeLegTarget(fourLegOffsetData[3], $fourLegOffsetT, 1, 0, 0, fourLegOffsetSequence).x"
                            data-attr-cy="computeLegTarget(fourLegOffsetData[3], $fourLegOffsetT, 1, 0, 0, fourLegOffsetSequence).y"
                            data-attr-r="0.5+computeLegTarget(fourLegOffsetData[3], $fourLegOffsetT, 1, 0, 0, fourLegOffsetSequence).z"
                            data-attr-fill="computeLegTarget(fourLegOffsetData[3], $fourLegOffsetT, 1, 0, 0, fourLegOffsetSequence).z > 0 ? 'none' : fourLegOffsetData[3].color"
                            data-attr-stroke="fourLegOffsetData[3].color" stroke-width="0.25"></circle>
                    </svg>
                    <button data-on-click="$fourLegOffsetEnabled = !$fourLegOffsetEnabled"><span
                            data-text="$fourLegOffsetEnabled ? 'Stop' : 'Start'"></span> Animation</button>

                </div>
            </div>

        </section>
        <section id="changing-directions">
            <h2>Crab Walking</h2>
            <p>
                Great! That works well for walking in a straight line at a constant speed. But what if we want to go in different directions or change speed?
            </p>
            <p>
                If we think of each step as an offset from the leg's resting position, we can rotate that offset to move in a different direction. We can also scale the offset based on speed.
            </p>
            <div style="display: flex; flex-direction: column; align-items: center; gap: 10px; padding: 10px;"
                data-signals="{fourLegSteeringT: 0, fourLegSteeringEnabled: false, fourLegSteeringAngle: 3.14, fourLegSteeringSpeed: 0}"
                data-on-interval__duration.200ms="$fourLegSteeringEnabled && $fourLegSteeringT++">
                <svg viewBox="-10 -10 20 20" width="200" height="200">
                    <circle r="1" cx="0" cy="0" stroke="light-dark(black, white)" fill="none" stroke-width="0.25">
                    </circle>
                    <circle
                        data-attr-cx="computeLegTarget(fourLegOffsetData[0], $fourLegSteeringT, $fourLegSteeringSpeed, $fourLegSteeringAngle, 0, fourLegOffsetSequence).x"
                        data-attr-cy="computeLegTarget(fourLegOffsetData[0], $fourLegSteeringT, $fourLegSteeringSpeed, $fourLegSteeringAngle, 0, fourLegOffsetSequence).y"
                        data-attr-r="0.5+computeLegTarget(fourLegOffsetData[0], $fourLegSteeringT, $fourLegSteeringSpeed, $fourLegSteeringAngle, 0, fourLegOffsetSequence).z"
                        data-attr-fill="computeLegTarget(fourLegOffsetData[0], $fourLegSteeringT, $fourLegSteeringSpeed, $fourLegSteeringAngle, 0, fourLegOffsetSequence).z > 0 ? 'none' : fourLegOffsetData[0].color"
                        data-attr-stroke="fourLegOffsetData[0].color" stroke-width="0.25"></circle>
                    <circle
                        data-attr-cx="computeLegTarget(fourLegOffsetData[1], $fourLegSteeringT, $fourLegSteeringSpeed, $fourLegSteeringAngle, 0, fourLegOffsetSequence).x"
                        data-attr-cy="computeLegTarget(fourLegOffsetData[1], $fourLegSteeringT, $fourLegSteeringSpeed, $fourLegSteeringAngle, 0, fourLegOffsetSequence).y"
                        data-attr-r="0.5+computeLegTarget(fourLegOffsetData[1], $fourLegSteeringT, $fourLegSteeringSpeed, $fourLegSteeringAngle, 0, fourLegOffsetSequence).z"
                        data-attr-fill="computeLegTarget(fourLegOffsetData[1], $fourLegSteeringT, $fourLegSteeringSpeed, $fourLegSteeringAngle, 0, fourLegOffsetSequence).z > 0 ? 'none' : fourLegOffsetData[1].color"
                        data-attr-stroke="fourLegOffsetData[1].color" stroke-width="0.25"></circle>
                    <circle
                        data-attr-cx="computeLegTarget(fourLegOffsetData[2], $fourLegSteeringT, $fourLegSteeringSpeed, $fourLegSteeringAngle, 0, fourLegOffsetSequence).x"
                        data-attr-cy="computeLegTarget(fourLegOffsetData[2], $fourLegSteeringT, $fourLegSteeringSpeed, $fourLegSteeringAngle, 0, fourLegOffsetSequence).y"
                        data-attr-r="0.5+computeLegTarget(fourLegOffsetData[2], $fourLegSteeringT, $fourLegSteeringSpeed, $fourLegSteeringAngle, 0, fourLegOffsetSequence).z"
                        data-attr-fill="computeLegTarget(fourLegOffsetData[2], $fourLegSteeringT, $fourLegSteeringSpeed, $fourLegSteeringAngle, 0, fourLegOffsetSequence).z > 0 ? 'none' : fourLegOffsetData[2].color"
                        data-attr-stroke="fourLegOffsetData[2].color" stroke-width="0.25"></circle>
                    <circle
                        data-attr-cx="computeLegTarget(fourLegOffsetData[3], $fourLegSteeringT, $fourLegSteeringSpeed, $fourLegSteeringAngle, 0, fourLegOffsetSequence).x"
                        data-attr-cy="computeLegTarget(fourLegOffsetData[3], $fourLegSteeringT, $fourLegSteeringSpeed, $fourLegSteeringAngle, 0, fourLegOffsetSequence).y"
                        data-attr-r="0.5+computeLegTarget(fourLegOffsetData[3], $fourLegSteeringT, $fourLegSteeringSpeed, $fourLegSteeringAngle, 0, fourLegOffsetSequence).z"
                        data-attr-fill="computeLegTarget(fourLegOffsetData[3], $fourLegSteeringT, $fourLegSteeringSpeed, $fourLegSteeringAngle, 0, fourLegOffsetSequence).z > 0 ? 'none' : fourLegOffsetData[3].color"
                        data-attr-stroke="fourLegOffsetData[3].color" stroke-width="0.25"></circle>
                    <!-- Let's add a line from the center into the direction of travel -->
                    <path
                        data-attr-d="`M 0 0 L ${3*$fourLegSteeringSpeed*Math.cos($fourLegSteeringAngle)} ${3*$fourLegSteeringSpeed*Math.sin($fourLegSteeringAngle)}`"
                        data-attr-stroke="$fourLegSteeringSpeed >= 0 ? 'light-dark(black, white)' : 'red'"
                        stroke="light-dark(black, white)" opacity=".75" stroke-width=".25" fill="none"></path>
                </svg>
                <div style="width: 200px">
                    <label for="direction-input">Direction</label>
                    <input id="direction-input" type="range" data-bind-four-leg-steering-angle min="0" max="6.28"
                        step="0.01">
                </div>
                <div style="width: 200px">
                    <label for="direction-input">Speed</label>
                    <input id="direction-input" type="range" data-bind-four-leg-steering-speed min="-1" max="1"
                        step="0.1">
                </div>
                <button data-on-click="$fourLegSteeringEnabled = !$fourLegSteeringEnabled"><span
                        data-text="$fourLegSteeringEnabled ? 'Stop' : 'Start'"></span> Animation</button>
            </div>
            <p>We can do this by treating the target position as a vector and rotating it around the center of the robot. This sounds complicated but is actually pretty simple. We use these formulas:</p>
            
            <p><strong>New X = X × cos(angle) - Y × sin(angle)</strong></p>
            <p><strong>New Y = X × sin(angle) + Y × cos(angle)</strong></p>
            
            <p>We can also change the speed by multiplying the offset by the speed value.</p>
        </section>
        <section id="turning">
            <h2>Turning</h2>
            <p>
                We also want to be able to turn - it would be a pretty boring robot if we couldn't do that! Let's think about how a differential drive robot turns: the left side and the right side move at different speeds. We can do the same thing with legs by varying the speed of individual legs.
            </p>
            <p>
                This is a bit more complicated because we need to know where each leg is in relation to the direction we want to turn.
            </p>
            <p>We use the angle between the leg and the direction we want to turn to figure out if the leg is on the inside or outside of the turn. Then we add or subtract the turning speed depending on whether the leg is on the inside or outside.</p>
            <div style="display: flex; flex-direction: column; align-items: center; gap: 10px; padding: 10px;"
                data-signals="{fourLegTurningT: 0, fourLegTurningEnabled: false, fourLegTurningAngle: 3.14, fourLegTurningSpeed: 0, fourLegTurningSteer: 0}"
                data-on-interval__duration.200ms="$fourLegTurningEnabled && $fourLegTurningT++">
                <svg viewBox="-10 -10 20 20" width="200" height="200">
                    <circle r="1" cx="0" cy="0" stroke="light-dark(black, white)" fill="none" stroke-width="0.25">
                    </circle>
                    <circle
                        data-attr-cx="computeLegTarget(fourLegOffsetData[0], $fourLegTurningT, $fourLegTurningSpeed, $fourLegTurningAngle, $fourLegTurningSteer, fourLegOffsetSequence).x"
                        data-attr-cy="computeLegTarget(fourLegOffsetData[0], $fourLegTurningT, $fourLegTurningSpeed, $fourLegTurningAngle, $fourLegTurningSteer, fourLegOffsetSequence).y"
                        data-attr-r="0.5+computeLegTarget(fourLegOffsetData[0], $fourLegTurningT, $fourLegTurningSpeed, $fourLegTurningAngle, $fourLegTurningSteer, fourLegOffsetSequence).z"
                        data-attr-fill="computeLegTarget(fourLegOffsetData[0], $fourLegTurningT, $fourLegTurningSpeed, $fourLegTurningAngle, $fourLegTurningSteer, fourLegOffsetSequence).z > 0 ? 'none' : fourLegOffsetData[0].color"
                        data-attr-stroke="fourLegOffsetData[0].color"
                        stroke-width="0.25"></circle>
                    <circle
                        data-attr-cx="computeLegTarget(fourLegOffsetData[1], $fourLegTurningT, $fourLegTurningSpeed, $fourLegTurningAngle, $fourLegTurningSteer, fourLegOffsetSequence).x"
                        data-attr-cy="computeLegTarget(fourLegOffsetData[1], $fourLegTurningT, $fourLegTurningSpeed, $fourLegTurningAngle, $fourLegTurningSteer, fourLegOffsetSequence).y"
                        data-attr-r="0.5+computeLegTarget(fourLegOffsetData[1], $fourLegTurningT, $fourLegTurningSpeed, $fourLegTurningAngle, $fourLegTurningSteer, fourLegOffsetSequence).z"
                        data-attr-fill="computeLegTarget(fourLegOffsetData[1], $fourLegTurningT, $fourLegTurningSpeed, $fourLegTurningAngle, $fourLegTurningSteer, fourLegOffsetSequence).z > 0 ? 'none' : fourLegOffsetData[1].color"
                        data-attr-stroke="fourLegOffsetData[1].color" stroke-width="0.25"></circle>
                    <circle
                        data-attr-cx="computeLegTarget(fourLegOffsetData[2], $fourLegTurningT, $fourLegTurningSpeed, $fourLegTurningAngle, $fourLegTurningSteer, fourLegOffsetSequence).x"
                        data-attr-cy="computeLegTarget(fourLegOffsetData[2], $fourLegTurningT, $fourLegTurningSpeed, $fourLegTurningAngle, $fourLegTurningSteer, fourLegOffsetSequence).y"
                        data-attr-r="0.5+computeLegTarget(fourLegOffsetData[2], $fourLegTurningT, $fourLegTurningSpeed, $fourLegTurningAngle, $fourLegTurningSteer, fourLegOffsetSequence).z"
                        data-attr-fill="computeLegTarget(fourLegOffsetData[2], $fourLegTurningT, $fourLegTurningSpeed, $fourLegTurningAngle, $fourLegTurningSteer, fourLegOffsetSequence).z > 0 ? 'none' : fourLegOffsetData[2].color"
                        data-attr-stroke="fourLegOffsetData[2].color" stroke-width="0.25"></circle>
                    <circle
                        data-attr-cx="computeLegTarget(fourLegOffsetData[3], $fourLegTurningT, $fourLegTurningSpeed, $fourLegTurningAngle, $fourLegTurningSteer, fourLegOffsetSequence).x"
                        data-attr-cy="computeLegTarget(fourLegOffsetData[3], $fourLegTurningT, $fourLegTurningSpeed, $fourLegTurningAngle, $fourLegTurningSteer, fourLegOffsetSequence).y"
                        data-attr-r="0.5+computeLegTarget(fourLegOffsetData[3], $fourLegTurningT, $fourLegTurningSpeed, $fourLegTurningAngle, $fourLegTurningSteer, fourLegOffsetSequence).z"
                        data-attr-fill="computeLegTarget(fourLegOffsetData[3], $fourLegTurningT, $fourLegTurningSpeed, $fourLegTurningAngle, $fourLegTurningSteer, fourLegOffsetSequence).z > 0 ? 'none' : fourLegOffsetData[3].color"
                        data-attr-stroke="fourLegOffsetData[3].color" stroke-width="0.25"></circle>
                    <path
                        data-attr-d="`M 0 0 L ${3*$fourLegTurningSpeed*Math.cos($fourLegTurningAngle)} ${3*$fourLegTurningSpeed*Math.sin($fourLegTurningAngle)}`"
                        data-attr-stroke="$fourLegTurningSpeed >= 0 ? 'light-dark(black, white)' : 'red'"
                        stroke="light-dark(black, white)" opacity=".75" stroke-width=".25" fill="none"></path>
                    <path
                        data-attr-d="`M 0 0 L ${$fourLegTurningSteer*$fourLegTurningSpeed*Math.cos($fourLegTurningAngle+Math.PI/2)} ${$fourLegTurningSteer*$fourLegTurningSpeed*Math.sin($fourLegTurningAngle+Math.PI/2)}`"
                        data-attr-stroke="$fourLegTurningSpeed >= 0 ? 'light-dark(black, white)' : 'red'"
                        stroke="light-dark(black, white)" opacity=".75" stroke-width=".25" fill="none"></path>
                </svg>
                <div style="width: 200px">
                    <label for="direction-input">Direction</label>
                    <input id="direction-input" type="range" data-bind-four-leg-turning-angle min="0" max="6.28"
                        step="0.01">
                </div>
                <div style="width: 200px">
                    <label for="direction-input">Speed</label>
                    <input id="direction-input" type="range" data-bind-four-leg-turning-speed min="-1" max="1"
                        step="0.1">
                </div>
                <div style="width: 200px">
                    <label for="direction-input">Steer</label>
                    <input id="direction-input" type="range" data-bind-four-leg-turning-steer min="-1" max="1"
                        step="0.1">
                </div>
                <button data-on-click="$fourLegTurningEnabled = !$fourLegTurningEnabled"><span
                        data-text="$fourLegTurningEnabled ? 'Stop' : 'Start'"></span> Animation</button>
            </div>
        </section>
    </main>
    <!-- ./ Main -->

    <!-- Footer -->
    <footer class="container">
        <small>Built by hand with <a href="https://data-star.dev/">Datastar</a> and <a
                href="https://picocss.com">Pico</a></small>
    </footer>
    <!-- ./ Footer -->


</body>

<script type="module" src="https://cdn.jsdelivr.net/gh/starfederation/datastar@main/bundles/datastar.js"></script>

</html>